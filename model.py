# -*- coding: utf-8 -*-
"""model.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-bon5KhZq2dCrdcM83r7KKUU79p0khR-
"""

import pandas as pd
import numpy as np

users = pd.read_csv("users.csv")
swipes = pd.read_csv("swipes.csv")

list(users.columns)

users_new = users[["gender", "interests", "is_verified", "status", "is_subscribed", "createdAt", "updatedAt"]]
users_new

list(swipes.columns)

swipes_new = swipes[["first_like_unlike_at", "is_unmatch", "like_count", "p1", "p2", "first_type", "second_type", "second_like_unlike_at", "unmatch_on"]]

swipes_new

swipes_new.describe

users_new

users_new = users_new.dropna()

users_new["is_verified"] = users_new["is_verified"].apply(lambda x: 0 if x=="False" else 1)
users_new["status"] = users_new["status"].apply(lambda x: 0 if x=="False" else 1)
users_new["is_subscribed"] = users_new["is_subscribed"].apply(lambda x: 0 if x=="False" else 1)

users_new

set(swipes_new.is_unmatch.values)

swipes_new = swipes[["is_unmatch", "p1",	"p2",	"first_type",	"second_type"]]
swipes_new["is_unmatch"] = swipes_new["is_unmatch"].apply(lambda x: 1 if x== False else 0)
swipes_new["first_type"] = swipes_new["first_type"].apply(lambda x: 0 if x=="DISLIKE" else 1)
swipes_new["second_type"] = swipes_new["second_type"].apply(lambda x: 0 if x=="DISLIKE" else 1)

swipes_new=swipes_new.dropna()

swipes_new

l = []
y = []

for i in swipes_new.values:
  l.append([i[1], i[2]])
  y.append(i[0])

len(l)

import json

# example string format data
data = list(users_new['interests'])

# convert each string to a list using json.loads
list_of_lists = [json.loads(s) for s in data]

print(list_of_lists)

import itertools

# flatten out the list using itertools.chain
ints = list(itertools.chain(*list_of_lists))

print(ints)

d = {value: index for index, value in enumerate(ints)}

def one_hot(lis):
  
  ret = [1 if value in lis else 0 for value in ints]

  return ret

l

fm = pd.DataFrame([], columns= ["Gender1", "interests1", "is_verified1", "status1", "is_subscribed1", "Gender2", "interests2", "is_verified2", "status2", "is_subscribed2", "is_unmatch"])
fm

len(y)

for i in range(len(l)):
  try:
    lh = l[i][0]
    hh = l[i][1]
    row_lst = list(users_new.loc[lh][:5].values) + list(users_new.loc[hh][:5].values) + [y[i]]

    if(row_lst[0]=='F'):
      row_lst[0]=1
    else:
      row_lst[0]=0

    if(row_lst[5]=='F'):
      row_lst[5]=1
    else:
      row_lst[5]=0

    fm.loc[len(fm)] = row_lst
  except:
    continue
fm

import json

# example string format data
data = list(fm['interests1'])

# convert each string to a list using json.loads
list_of_lists = [json.loads(s) for s in data]

print(list_of_lists)

fm["interests1"] = [one_hot(i) for i in list_of_lists]

import json

# example string format data
data = list(fm['interests2'])

# convert each string to a list using json.loads
list_of_lists = [json.loads(s) for s in data]

print(list_of_lists)

fm["interests2"] = [one_hot(i) for i in list_of_lists]

fm

expanded_df = fm['interests1'].apply(pd.Series)

# concatenate the expanded columns with the original DataFrame
fm1 = pd.concat([fm, expanded_df], axis=1)

# drop the original column
fm1 = fm1.drop('interests1', axis=1)

fm1

expanded_df = fm1['interests2'].apply(pd.Series)

# concatenate the expanded columns with the original DataFrame
fm2 = pd.concat([fm1, expanded_df], axis=1)

# drop the original column
fm2 = fm2.drop('interests2', axis=1)

fm2

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.tree import DecisionTreeClassifier

X = fm2.drop('is_unmatch', axis=1).to_numpy()
y = fm2['is_unmatch'].to_numpy()

# split the data into training and test sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# create and fit a decision tree classifier
clf = DecisionTreeClassifier()
clf.fit(X_train, y_train)

# predict the target variable for the test set
y_pred = clf.predict(X_test)

# evaluate the model's performance
accuracy = np.mean(y_pred == y_test)
print('Accuracy:', accuracy)

y_proba = clf.predict_proba(X_test)
y_pred = y_proba[:, 1]
y_pred

X_test.shape

import joblib

joblib.dump(clf, 'match_predict.joblib')

np.save('x_train', X)
np.save('y_train', y)

fm.to_csv('feature_matrix.csv')